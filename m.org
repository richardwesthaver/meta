#+TITLE: metas
#+SETUPFILE: ox.setup
* meta                                                             :org:docs:
:PROPERTIES:
:CUSTOM_ID: meta
:EXPORT_FILE_NAME: readme
:END:
This project contains documents I've written in plain-text used to
generate my [[https://rwest.io][website]] and readme files for code hosted at [[src:][hg.rwest.io]].

#+name: meta-make-tbl
#+header: :var name=(org-sbx org-current-heading-title) :var age=hg-log-age()
#+header: :var rev=(org-sbx hg-rev (path (concat "/home/ellis/shed/src/" (org-sbx org-current-heading-title))))
#+header: :var num=(org-sbx hg-id-num (path (concat "/home/ellis/shed/src/" (org-sbx org-current-heading-title))))
#+header: :var lc=(org-sbx wc-dir-lines (dir (concat "/home/ellis/shed/src/" (org-sbx org-current-heading-title))))
#+header: :var cc1=(org-sbx tokei-dir-lines (dir (concat "/home/ellis/shed/src/" (org-sbx org-current-heading-title))))
#+header: :var cc2=(org-sbx tokei-dir-langs (dir (concat "/home/ellis/shed/src/" (org-sbx org-current-heading-title))))
#+header: :var ver="alpha-0.1"
#+begin_src emacs-lisp :exports results :results table :eval no-export
    (let* ((nf (format "[[https://rwest.io/m#%s][%s]]" name name))
           (rf (format "[[https://hg.rwest.io/%s/rev/%s][%s:%s]]" name rev num rev))
           (gf (format "[[https://github.com/richardwesthaver/%s][github]]" name))
           (vf (format "%s, %s" rf gf))
           (lsum (org-sbe sum-str-nums ('x 'cc1)))
           (l (split-string cc1))
           (lang (split-string cc2))
           (cf (format "%s = λ:%s #:%s _:%s" lsum (pop l) (pop l) (pop l))))
      `(("info", "")
        hline
        ("name" ,nf)
        ("version" ,ver)
        ("vc" ,vf)
        ("updated" ,age)
        ("lines" ,cf)
        ("langs" ,lang)
        hline))
#+end_src

#+RESULTS: meta-make-tbl
| info    |                          |
|---------+--------------------------|
| name    | [[https://rwest.io/m#meta][meta]]                     |
| version | alpha-0.1                |
| vc      | [[https://hg.rwest.io/meta/rev/09a7c7a6ad64][73+:09a7c7a6ad64]], [[https://github.com/richardwesthaver/meta][github]] |
| updated | 26 hours ago             |
| lines   | 6946 = λ:6440 #:29 _:477 |
| langs   | (Org)                    |
|---------+--------------------------|


#+name: _meta-files
#+begin_src sh :results silent :exports none
  ls -lh --time-style=long-iso \
    |awk '{if (NR!=1) print $8, $5, $6"-"$7}' \
    |awk 'BEGIN{print "file size updated"}{print $0}'
#+end_src

#+name: meta-files 
#+begin_src emacs-lisp :var ft=_meta-files :results table :colnames yes :hlines yes :exports results
ft
#+end_src

#+RESULTS: meta-files
| file       | size |          updated |
|------------+------+------------------|
| cv.org     | 3.8K | 2021-10-27-20:37 |
| index.org  | 4.6K | 2021-11-17-23:56 |
| m.org      | 38K  | 2021-11-18-01:08 |
| n.org      | 229K | 2021-11-14-17:37 |
| ox.setup   | 580  | 2021-11-14-23:06 |
| readme.org | 8.7K | 2021-11-18-00:54 |

#+CALL: shc-hg-summary() :eval yes
#+RESULTS:
: parent: 73:09a7c7a6ad64 tip
:  script refinement
: branch: default
: commit: 2 modified
: update: (current)
: M m.org
: M readme.org

** scripts
:PROPERTIES:
:CUSTOM_ID: meta-scripts
:END:
*** index
:PROPERTIES:
:CUSTOM_ID: meta-index
:END:
*** deploy
:PROPERTIES:
:CUSTOM_ID: meta-deploy
:END:

This is the script for deploying metas. It usually takes a few minutes
to run and chains together a bunch of code blocks, but is otherwise
fully automated.

#+name: meta-prod-vars
| key   | val              | notes             |
|-------+------------------+-------------------|
| wd    | ~/shed/src/meta/ | working directory |
| files |                  | input files       |
| rh    | /sshx:hyde:      | remote host       |
| o     | o/               | output directory  |

#+name: meta-val
#+begin_src emacs-lisp :results value :var tbl=meta-prod-vars idx=0 :exports none
  (nth idx (mapcar (lambda (x) (cadr x)) tbl))
#+end_src

This block is the main entry point that gets executed - each call to
=org-sbx= (a custom function based on =org-sbe=) executes the contents
of a named code block.

#+name: meta-deploy-main
#+begin_src emacs-lisp :results silent
  (org-sbx meta-tmp)
  (org-sbx meta-pub)
  (org-sbx meta-pack)
  (org-sbx meta-deploy)
  (org-sbx meta-readme-gen)
  (org-sbx meta-clean)
;  (org-sbx meta-commit)
  (org-sbx meta-mirror)
#+end_src

First we generate the output directory and copy source files there.
This ensures the root project directory isn't polluted on export. You
could also do an initial export to generate pre-parsed files (with
comments and headings tagged with =noexport= removed) in the output
directory instead of copying the raw source. This is great for docs
with sensitive info, but I prefer the copy method for public projects.

#+name: meta-tmp 
#+begin_src emacs-lisp :var o=meta-val(idx=3) :results silent
  (let ((path (concat o "org/"))
        (files (list "m.org" "n.org" "index.org" "cv.org" "ox.setup")))
    (make-directory path t)
    (dolist (f files)
      (copy-file f path t))
    (message "created meta-tmp dir"))
#+end_src

Org has integrated [[https://orgmode.org/manual/Exporting.html][exporting]] powered by [[https://orgmode.org/worg/exporters/ox-docstrings.html][ox.el]] - an emacs-lisp script
is all that is needed to generate conventional formats like HTML,
Markdown, PDF, and txt. Exported files are saved in separate
directories.

#+name: meta-pub
#+begin_src emacs-lisp :results silent
  (require 'ox)
  (require 'org-refile)
  (require 'htmlize "~/shed/src/contrib/el/htmlize/htmlize.el")
  (require 'org-id)
  (setq org-html-validation-link nil
        ;;        org-html-htmlize-output-type 'css
        org-export-with-author nil)

  (load-theme 'modus-operandi)
  (setq org-publish-project-alist
        '(("org-html"
           :author "ellis"
           :email "ellis@rwest.io"
           :base-directory "~/shed/src/meta/o/org"
           :base-extension "org"
           :with-date (current-time)
           :publishing-directory "~/shed/src/meta/o/html"
           :publishing-function org-html-publish-to-html
           :htmlize-source t
           :auto-sitemap nil)
          ("org-md"
           :author "ellis"
           :email "ellis@rwest.io"
           :base-directory "~/shed/src/meta/o/org"
           :base-extension "org"
           :with-date (current-time)
           :publishing-directory "~/shed/src/meta/o/md"
           :recursive t
           :publishing-function org-md-publish-to-md
           :auto-sitemap nil)
          ("org-pdf"
           :author "ellis"
           :email "ellis@rwest.io"
           :base-directory "~/shed/src/meta/o/org"
           :base-extension "org"
           :with-date (current-time)
           :publishing-directory "~/shed/src/meta/o/pdf"
           :recursive t
           :publishing-function org-latex-publish-to-pdf
           :auto-sitemap nil)
          ("org-txt"
           :author "ellis"
           :email "ellis@rwest.io"
           :base-directory "~/shed/src/meta/o/org"
           :base-extension "org"
           :with-date (current-time)
           :publishing-directory "~/shed/src/meta/o/txt"
           :recursive t
           :publishing-function org-ascii-publish-to-ascii
           :auto-sitemap nil)
          ("all" :components ("org-html" "org-md" "org-pdf" "org-txt"))))

  (org-publish-remove-all-timestamps)
  (org-refile-cache-clear)
  (org-publish "all" t)
  (load-theme current-theme)
#+end_src

First we clean some of the junk latex produced by the PDF export, then
compress our exports to =.tz= (tar.zst) archives.

#+name: meta-pack
#+begin_src sh :var o=meta-val(idx=3) :results silent
  cd $o/org
  rm -rf *.pdf *.tex
  cd ..
  for i in $(find ./* -maxdepth 0 -type d);
  do
      shc pack $i
  done
#+end_src

All build artifacts are transferred over SSH to a public web
server. New content can now be viewed online at [[https://rwest.io][rwest.io]] and
downloaded at [[https://rwest.io/x][rwest.io/x]] which includes archives and individual files
in all formats.

#+name: meta-deploy
#+begin_src emacs-lisp :var o="o/" rh="/sshx:hyde:/mnt/w/" files='("m.html" "n.html" "index.html") :results silent
  (copy-file o (concat rh "x/") 1)
  (dolist (f files)
    (copy-file (concat o "html/" f) rh 1))
  (copy-file (concat o "pdf/cv.pdf") rh 1)
#+end_src


Next we execute a helper function from my [[#cfg-emacs][emacs config]]. This function
scans the current file (=m.org=) and generates individual =readme.org=
files for our projects.

#+name: meta-readme-gen
#+begin_src emacs-lisp :results silent
  (org-export-headings-to-org)
#+end_src

Here's the docstring for =org-export-headings-to-org=:
#+begin_quote
Export all subtrees that are *not* tagged with :noexport: to
separate files.

Subtrees that do not have the :EXPORT_FILE_NAME: property set
are exported to a filename derived from the headline text.
#+end_quote

What's going on here? Well to start, we are indeed using the
=:EXPORT_FILE_NAME:= property in our headlines. This allows us to
generate the same 'filename' (=readme.org=) in respective project
directories. They also look quite nice on GitHub without any
additional configuration ;).

Before we talk about github stuff, let's commit the readme changes for
our projects - first let's clean up build artifacts.
#+name: meta-clean
#+begin_src shell :results silent
  rm -rf o
#+end_src

Now we can commit without being skeptical about the repo state.

#+name: meta-commit
#+begin_src shell :results silent
  for i in shed rlib tenex babel cfg demo meta; do
      cd ~/shed/src/$i && hg ci -m 'meta-commit update'
  done
#+end_src

Ok, now let's push our changes to github. Note that this creates lots
of commits, but we don't really care since it's a mirror. I'm just
testing this as an alternative approach to a 'pure' VC mirror which
would include all commits, branches, etc. I'll probably just switch
back to the [[https://hg-git.github.io/][hg-git]] 'pure' solution soon.

#+name: meta-mirror
#+begin_src bash :results value silent :eval no-export
  REPOS=("meta" "shed" "babel" "cfg" "tenex" "rlib")
  WD=$STAMP
  for r in ${REPOS[@]}; do
      src=$SHED/src/$r
      gh=git@github.com:richardwesthaver/$r.git
      rm -rf $WD/$r
      git clone $gh $WD/$r
      pushd $WD/$r
      case $r in
          meta) cp -rf $src/{m.org,n.org,cv.org,index.org,ox.setup,readme.org} ./ ;;
          shed) cp -rf $src/{Cargo.toml,build.rs,lisp,makefile,src,readme.org,rustfmt.toml} ./ ;;
          babel) cp -rf $src/{babel.el,lob.org,readme.org,makefile,sc} ./ ;;
          rlib) cp -rf $src/{Cargo.toml,.cargo,rustfmt.toml,src,alch,audio,crypto,db,eve,flate,fu,hash,kala,logger,math,net,obj,organ,tests,ui,util,readme.org} ./ ;;
          cfg) cp -rf $src/{emacs,mail,shell,term,tmux,vc,virt,wm,readme.org} ./ ;;
          tenex) cp -rf $src/{src,aws,google,readme.org,rustfmt.toml,Cargo.toml} ./ ;;
      esac
      git add .
      git commit -m "from https://hg.rwest.io/$r"
      git push
      popd
  done
#+end_src

**** docs                                                       :noexport:
:PROPERTIES:
:CUSTOM_ID: meta-prod-docs
:END:
Generate API docs for all Rust projects
#+name: shed-gen-rust-docs
#+begin_src sh
  WD=$SHED/src
  O=$WD/meta/o/d
  cd $WD
  for i in rlib tenex shed; do # shed
      cd $i
      cargo +nightly doc --target-dir $O --no-deps --all-features --workspace --release --message-format short
      cd ..
  done
  cd $O
  mv doc/* ./ && rm -r doc release
#+end_src

#+name: meta-deploy-rust-docs
#+begin_src elisp :results silent
  (copy-file "o/d" "/sshx:hyde:/mnt/w/d" 1)
#+end_src
**** makefile                                                   :noexport:
:PROPERTIES:
:CUSTOM_ID: meta-prod-makefile
:header-args: :results silent :eval no-export
:END:
#+begin_src makefile :tangle makefile :shebang "#!/usr/bin/make -f -j8"
  PUB := ./pub.el
  OX_SETUP := ./ox.setup

  HD ?= dmz
  P ?= html md txt pdf org

  MD = mkdir -p $(@)

  .PHONY: c

  o:o/x;shed pack $< $<.tz;
  $(foreach p,$(P), shed pack $</${p} $@/${p}.tz;)

  w:o;ssh $(HD) rm -rf dmz/w/*.html;\
  scp -r $</x/html/*.html $(HD):dmz/w;\
  scp -r $</*.tz $(HD):dmz/w/x

  c:;rm -rf o

  o/x:$(OX_SETUP) $(PUB);$(MD)/org;cp ./*.org $< o/x/org;$(PUB);\
  ssh $(HD) rm -rf dmz/w/*.html; scp -r $@/html/*.html $(HD):dmz/w/;\
  shed pack $@ o/x.tz;scp -r $@ $(HD):dmz/w
#+end_src

** syntax
:PROPERTIES:
:CUSTOM_ID: meta-syntax
:END:
The source files assume some familiarity with org syntax. Org syntax
is covered [[https://orgmode.org/worg/dev/org-syntax.html][online]] in detail and high-level info about document
structure can be found in the [[info:emacs#Top][Emacs manual]].

#+attr_html: :width 600
#+attr_latex: :width 600
[[cdn:img/org-mode-features_display.png]]

All docs are fully compliant with org, with the addition of some
special *elements*:

- props :: \\
  - All nodes have an optional number of =props= which are simply list
    items starting with =+= followed by the =prop-key= an assignment
    operator (=--=, =<-=, =->=), and a =prop-val=.
    #+begin_example
    # [+] [KEY] [OP] [VAL]
    + what -- an example
    #+end_example
  - the =prop-val= type is determined by the operator. It can be a
    string =--=, list =->=, or empty =<-=.
  - =props= can appear anywhere in the =section= element of a node
    (not just immediately following properties drawer). With the
    condition that they can't be embedded (props in =prop-val=).
- drawers :: \\
  Org-mode has a feature called drawers, which are collapsible
  sections of text starting with =:DRAWER_NAME:= and ending with
  =:END:=. The most common one seen in our docs is the PROPERTIES
  drawer, but there are a few special ones we use, especially in
  =n.org=: =note=, =opinion=, =props= =boris=.
- links ::
  In addition to the default links, we use a few custom links, most
  notably =yt= which embeds a video from youtube.
  :note:
  This is not good for users, since the embedded youtube links include
  tracking and other nasty bits from Google. In the future these links
  will be migrated to =cdn= to avoid that, increasing user privacy and
  greatly improving page load time.
  :end:
  =cdn=, =src=, and =rw= links all point to =rwest.io=.

* babel                                                            :org:prog:
:PROPERTIES:
:ID:       1b363810-26ea-4dae-b689-6e050756bfae
:CUSTOM_ID: babel
:CATEGORY: lib
:EXPORT_FILE_NAME: ../babel/readme
:END:

This project is an extension of the [[https://orgmode.org/manual/Library-of-Babel.html][Library of Babel]] - which allows
you to define blocks of code in an org file, and call them remotely
(from elsewhere within Emacs). Emacs was previously distributed with
an initial collection; [[https://git.sr.ht/~bzg/worg/tree/master/item/library-of-babel.org][library-of-babel.org]]. This is no longer the
case, but the powerful functionality of =org-babel= is still there.

=babel.el= is the core package for this library. It includes a few
extensions to built-in packages, a minor-mode, and a framework for
using code blocks in various contexts. More on that later.

#+CALL: meta-make-tbl()
#+RESULTS:
| info    |                                                   |
|---------+---------------------------------------------------|
| name    | [[https://rwest.io/m#babel][babel]]                                             |
| version | alpha-0.1                                         |
| vc      | [[https://hg.rwest.io/babel/rev/fc31b7ffb5b2][75+:fc31b7ffb5b2]], [[https://github.com/richardwesthaver/babel][github]]                          |
| updated | 26 hours ago                                      |
| lines   | 6929 = λ:4712 #:805 _:829                         |
| langs   | (Elisp Haskell Makefile Org PowerShell Python Sh) |
|---------+---------------------------------------------------|

** Literate Programming
:PROPERTIES:
:CUSTOM_ID: babel-lp
:END:
Literate Programming (LP) was first introduced by Donald Knuth in 1984 via
his documentation and programming system =WEB=. The approach involves
writing the logic of a program in /natural language/ interspersed with
snippets, macros, and other source code, from which a compilable
computer program can be generated.

The concept can be applied widely but is typically reserved for the
domains of academia, where it is a popular method of creating
reproducible research.

Knuth's =WEB= was originally built for Pascal + LaTex /only/, but in
1989 a new language-agnostic tool called =noweb= was released. This
model, that is capable of working with multiple programming languages
and documentation backends, is what we commonly refer to as Literate
Programming today.

*** Weaving and Tangling
:PROPERTIES:
:CUSTOM_ID: lp-weave-tangle
:END:

[[https://rwest.io/a/img/literate_c.jpg]]

Weaving and Tangling are the core operations that are performed on
some raw source, which should include both prose and code. The raw
source is written in =org= in our case, but the same concepts apply to
other mediums such as Jupyter Notebooks.

the core functions of any LP system are =weave= and =tangle=.

- *Weaving* is associated with the /publishing/ and /exporting/
  pipeline for the source, which is meant to enhance the
  human-readable aspects. We =weave= an LP document into formats such
  as LaTex, HTML, and PDF for human consumption.

- *Tangling* is associated with the /compilation/ nand /build/
  pipeline for source. It creates raw source code files, sometimes
  with additional comments. These files are machine-readable and can
  be interpreted in the runtime of our choosing.

As it relates to our project =babel=, we are particularly interested
in the =tangle= function. I do enjoy a well-woven document and
reviewing LP code in that manner, and =babel= functions can be used to
compose LP documents which are in turn woven, but it doesn't play a
role in the implementation itself. Our focus is instead on
/ergonomics/, specifically for the programmer and the runtime
environment he finds himself in, which requires close attention to the
machine-readable formats of source blocks.

** Dependencies
:PROPERTIES:
:CUSTOM_ID: babel-deps
:END:
- *Emacs 28* \\
  The editor integration doesn't depend on any external packages
  outside of vanilla Emacs. The following built-in packages are used:
  - =org.el=
  - =ob.el=
  - =skeleton.el=
  - =autoinsert.el=
  - =abbrev.el=
  - =dabbrev.el=

* cfg                                                                   :etc:
:PROPERTIES:
:CUSTOM_ID: cfg
:EXPORT_FILE_NAME: ../cfg/readme
:END:
This repo contains [[https://wiki.archlinux.org/title/Dotfiles][dotfiles]] for various programs and applications I
use often.

#+CALL: meta-make-tbl()
#+RESULTS:
| info    |                                       |
|---------+---------------------------------------|
| name    | [[https://rwest.io/m#cfg][cfg]]                                   |
| version | alpha-0.1                             |
| vc      | [[https://hg.rwest.io/cfg/rev/8649c6171529][41+:8649c6171529]], [[https://github.com/richardwesthaver/cfg][github]]              |
| updated | 26 hours ago                          |
| lines   | 6929 = λ:1971 #:445 _:259             |
| langs   | (CHeader Elisp Lua Makefile Org Yaml) |
|---------+---------------------------------------|

| category | description                            | apps                |
|----------+----------------------------------------+---------------------|
| emacs    | the superior editor                    | emacs               |
| mail     | gmail local setup                      | offlineimap notmuch |
| shell    | shell profiles and configs             | bash zsh            |
| term     | terminal emulation and multiplexing    | urxvt tmux kitty    |
| vc       | version control                        | hg git              |
| virt     | machine emulation                      | lxc qemu archiso    |
| wm       | minimal X11 desktop config and widgets | 2bwm conky          |

The top-level makefile can be used for basic local bootstrap but these
files are generally intended to be loaded into a user environment via
the =shed= development tool. I work out of a Linux box 99% of the
time, but most programs are cross-platform. I don't bother with
Windows machines, but there is a =powershell= configuration that
provides some amenities when I need to use one. My default =emacs=
config also works on Windows but YMMV.

The sections below cover configuration of a certain category or
individual application such as =shell= or =emacs= respectively.

** emacs
:PROPERTIES:
:CUSTOM_ID: cfg-emacs
:END:
+ what -- Configuration for the superior editor.
+ version -- 2.1

I've been using Emacs since 2016 as my primary editor. I started with
[[https://www.spacemacs.org/][Spacemacs]], used [[https://github.com/hlissner/doom-emacs][Doom]] for a while, then started rolling my own
configurations. Configuring the Emacs editor requires learning the
Emacs language - [[https://www.gnu.org/software/emacs/manual/html_node/elisp/][Emacs Lisp]] or =elisp=. It is a dialect of Common Lisp
which can be a bit tricky to adapt to for non-Lisp programmers (such
as myself), but it is built specifically for Emacs and quite powerful.

This section covers my Emacs packages, configurations, and other code
written in =elisp=.
*** default.el
:PROPERTIES:
:ID:       673fb426-f80c-4b51-b2a7-27e330051da5
:END:
=default.el= provides a package called =default= which is always the
first package loaded in my init file. Why? because it doesn't require
/any/ external packages - only packages included with the vanilla GNU
Emacs distribution. This removes the need to bootstrap a package
manager, download remote packages, and do other things that can impact
startup time. It also guarantees my defaults will work on any platform
that supports vanilla Emacs.

*** hyde.el
:PROPERTIES:
:ID:       0366a755-e1c1-4002-a39e-cc9729bd8051
:END:
*** config.org
:PROPERTIES:
:ID:       6782d0a9-1915-4b3e-85fb-3dd5e7ec917e
:CUSTOM_ID: config-org
:END:
  #+attr_html: :width 500
  #+attr_latex: :width 500
  [[https://rwest.io/a/img/abyss-theme-emacs.png][https://rwest.io/a/img/abyss-theme-emacs.png]]
  #+attr_html: :width 500
  #+attr_latex: :width 500
  [[https://rwest.io/a/img/sanityinc-theme-emacs.png][https://rwest.io/a/img/sanityinc-theme-emacs.png]]
  #+attr_html: :width 500
  #+attr_latex: :width 500
  [[https://rwest.io/a/img/wheatgrass-theme-emacs.png][https://rwest.io/a/img/wheatgrass-theme-emacs.png]]
  #+attr_html: :width 500
  #+attr_latex: :width 500
  [[https://rwest.io/a/img/leuven-theme-emacs.png][https://rwest.io/a/img/leuven-theme-emacs.png]]
  #+attr_html: :width 500
  #+attr_latex: :width 500
  [[https://rwest.io/a/img/olivetti-emacs.png][https://rwest.io/a/img/olivetti-emacs.png]]
  #+attr_html: :width 500
  #+attr_latex: :width 500
  [[https://rwest.io/a/img/rust-development-emacs.png][https://rwest.io/a/img/rust-development-emacs.png]]
  #+attr_html: :width 500
  #+attr_latex: :width 500
  [[https://rwest.io/a/img/rust-tests-emacs.png][https://rwest.io/a/img/rust-tests-emacs.png]]
  #+attr_html: :width 500
  #+attr_latex: :width 500
  [[https://rwest.io/a/img/email-emacs.png][https://rwest.io/a/img/email-emacs.png]]
  #+attr_html: :width 500
  #+attr_latex: :width 500
  [[https://rwest.io/a/img/eww-emacs.png][https://rwest.io/a/img/eww-emacs.png]]
** mail
:PROPERTIES:
:CUSTOM_ID: cfg-mail
:END:
- notmuch
- offlineimap
** shell
:PROPERTIES:
:CUSTOM_ID: cfg-shell
:END:
- bash
- zsh
** term
:PROPERTIES:
:CUSTOM_DI: cfg-term
:END:
- kitty
** tmux
:PROPERTIES:
:CUSTOM_ID: cfg-tmux
:END:
** vc
:PROPERTIES:
:CUSTOM_ID: cfg-vc
:END:
- mercurial
- git
** virt
:PROPERTIES:
:CUSTOM_ID: cfg-virt
:END:
- lxc
- qemu
- archiso
** wm
:PROPERTIES:
:CUSTOM_ID: cfg-wm
:END:
- 2bwm
- conky
- lemonbar
** nix                                                 :deprecated:noexport:
:PROPERTIES:
:CUSTOM_ID: cfg-nix
:END:
Poorman's distributed =nix= config has fallen into disrepair, but I
keep it around for old-time's sake. It might come in handy in the
future, depending on how the Nix ecosystem progresses.
* shed                                                             :rust:dev:
:PROPERTIES:
:CUSTOM_ID: shed
:EXPORT_FILE_NAME: ../shed/readme
:END:
SelfHostED
#+CALL: meta-make-tbl()
#+RESULTS:
| info    |                                                |
|---------+------------------------------------------------|
| name    | [[https://rwest.io/m#shed][shed]]                                           |
| version | alpha-0.1                                      |
| vc      | [[https://hg.rwest.io/shed/rev/d696a8ae75d5][63+:d696a8ae75d5]], [[https://github.com/richardwesthaver/shed][github]]                       |
| updated | 26 hours ago                                   |
| lines   | 6935 = λ:2105 #:102 _:136                      |
| langs   | (Bash Elisp Makefile Org PowerShell Rust Toml) |
|---------+------------------------------------------------|

** Roadmap
:PROPERTIES:
:CUSTOM_ID: shed-roadmap
:END:
*** NEXT Registry
:PROPERTIES:
:ID:       b157b0bd-da91-4f0a-925f-39acfed569a7
:END:
:LOGBOOK:
- State "NEXT"       from              [2021-10-23 Sat 03:38]
:END:
- Domain -> Namespace -> ID
- [Domain/Namespace]:ID index tables for quick DHT-style lookups of resource
- Namespaces sharing the same Domain share the same Registry
- For a similar concept, see [[https://doc.redox-os.org/book/ch04-04-urls.html][RedoxOS URLs]]
*** HACK Commands
:PROPERTIES:
:END:
:LOGBOOK:
- State "HACK"       from "TODO"       [2021-10-23 Sat 03:41]
- State "TODO"       from              [2021-10-23 Sat 03:38]
:END:
**** TODO clean
:PROPERTIES:
:END:
:LOGBOOK:
- State "TODO"       from              [2021-10-24 Sun 07:06]
:END:
- =shed clean= ::
  - if CWD is a project directory, perform clean script from config.
  - elif INPUT is a project name, perform clean script from config.
  - elif cache !empty clean global cache.
  - else say 'nothing to clean'.
- ARGS
  - =--lab [LAB]= :: clean the specified lab environment
  - =--project [PROJECT]= :: clean the specified project
  - =--stash= :: clean the stash
  - =--store= :: clean the store
  - =--all= :: clean everything
**** TODO test
:PROPERTIES:
:END:
:LOGBOOK:
- State "TODO"       from              [2021-10-24 Sun 07:07]
:END:
- =shed test=
  - if CWD is project directory, perform test script from config.
  - elif INPUT is project name, perform test script from config.
  - else say 'nothing to test'
- ARGS
  -  =--all= => test everything
**** TODO list
:PROPERTIES:
:END:
:LOGBOOK:
- State "TODO"       from              [2021-10-24 Sun 07:07]
:END:
- =shed list= ::
  - =INPUT= :: projects, labs, stash, store
  - else list service stats
*** TODO Krypt
:PROPERTIES:
:END:
:LOGBOOK:
- State "TODO"       from              [2021-10-23 Sat 03:38]
:END:
- 
- based on intuitions from [[https://nacl.cr.yp.to/box.html][crypto_box]] 
*** TODO Babel
:PROPERTIES:
:END:
:LOGBOOK:
- State "TODO"       from              [2021-10-23 Sat 03:43]
:END:

*** TODO shed.el
:PROPERTIES:
:END:
:LOGBOOK:
- State "TODO"       from              [2021-10-23 Sat 03:39]
:END:
- daemon <-> process IPC
- bindat protocol definitions
- network daemon messages and packets
** Programs
:PROPERTIES:
:CUSTOM_ID: shed-features
:END:
- *shc*
  - CLI client
  - used to interact with the services
- *shx*
  - programming environments (REPLs)
    - embedded Python (RustPython)
    - APLs (BQN, k6/9, Gnu/Dyalog APL)
    - Elisp (ielm.el)
    - Erlang (erl)
    - Lua
- *shk*
  - krypt service
  - reasonably safe secret storage
    - Wireguard, SSH, TLS, plaintext
- *she*
  - emacs daemon service
- *shd*
  - prime daemon service
- *shs*
  - HTTP service daemon
** Installation
:PROPERTIES:
:CUSTOM_ID: shed-installation
:END:
Once the binary is installed, run =shc init -p= to bootstrap a via
prompts. The default config path is determined by the ~$SHED_CFG~
environment variable or ~$HOME/.config/shed.cfg~.

Some commands run just fine without writing a config to disk - A
default configuration is supplied when =shed.cfg= can't be
found. Other commands may panic in the event that a system or internal
path dependency is missing.

** Configuration
:PROPERTIES:
:CUSTOM_ID: shed-configuration
:END:
Global configuration is controlled by the [[https://docs.rwest.io/shed/config/struct.Config.html][Config struct]]. The
specification is non-exhaustive and can be extended by the user at
runtime or in code at compile.
#+begin_src rust
  pub struct Config {
    pub path: PathBuf,
    pub src: Vec<PackageConfig>,
    pub bin: Vec<ProgramConfig>,
    pub net: NetworkConfig,
    pub hg: MercurialConfig,
    pub lab: Vec<ProjectConfig>,
    pub usr: UserConfig,
  }
#+end_src

Configs can be deserialized from RON, JSON, or Bincode formats. I
prefer RON for writing local configuration, but feel free to use JSON
instead. Bincode is intended for =shed= internal processes such as IPC
and database storage, but exposed to the user for convenience.

- RON
  #+begin_src ron
    // cfg.ron
    #![enable(implicit_some)]
    (
      path: "~/shed",
      src: [],
      bin: [],
      net: (
        socket: "127.0.0.1:0",
        tunnel: None,
        engine: Http,
        peers: None,
      ),
      hg: (
        ui: {},
        extensions: None,
        paths: None,
        web: (
          name: "",
          contact: "",
          description: "",
          extensions: [],
          socket: "0.0.0.0:0",
          paths: {},
        ),
      ),
      lab: [],
      usr: (
        shell: (
          env: {},
          cmds: {},
          shell: Bash,
        ),
        geo: None,
        displays: None,
        packages: [],
        projects: [],
        auth: [],
      ),
    )
  #+end_src
- JSON
  #+begin_src json
{
  "path": "/home/ellis/shed",
  "src": [],
  "bin": [],
  "net": {
    "socket": "127.0.0.1:0",
    "tunnel": null,
    "engine": "Http",
    "peers": null
  },
  "hg": {
    "ui": {},
    "extensions": null,
    "paths": null,
    "web": {
      "name": "",
      "contact": "",
      "description": "",
      "extensions": [],
      "socket": "0.0.0.0:0",
      "paths": {}
    }
  },
  "lab": [],
  "usr": {
    "shell": {
      "env": {},
      "cmds": {},
      "shell": "Bash"
    },
    "geo": null,
    "displays": null,
    "packages": [],
    "projects": [],
    "auth": []
  }
}
  #+end_src
- BIN
  #+begin_src hexl
    00000000: 1000 0000 0000 0000 2f68 6f6d 652f 656c  ......../home/el
    00000010: 6c69 732f 7368 6564 0000 0000 0000 0000  lis/shed........
    00000020: 0000 0000 0000 0000 0000 0000 7f00 0001  ................
    00000030: 0000 0001 0000 0000 0000 0000 0000 0000  ................
    00000040: 0000 0000 0000 0000 0000 0000 0000 0000  ................
    00000050: 0000 0000 0000 0000 0000 0000 0000 0000  ................
    00000060: 0000 0000 0000 0000 0000 0000 0000 0000  ................
    00000070: 0000 0000 0000 0000 0000 0000 0000 0000  ................
    00000080: 0000 0000 0000 0000 0000 0000 0000 0000  ................
    00000090: 0000 0000 0000 0000 0000 0000 0000 0000  ................
    000000a0: 0000 0000 0000 0000 0000 0a              ...........
  #+end_src
** Commands
:PROPERTIES:
:CUSTOM_ID: shed-commands
:END:
#+begin_src shell :exports both :results output replace
  shc --help
#+end_src

#+RESULTS:
#+begin_example
shed 0.1.0-0fc01f4e2590+

ellis <ellis@rwest.io>

shed multi-development tool

USAGE:
    shed [FLAGS] [OPTIONS] [SUBCOMMAND]

FLAGS:
    -?               set the log level
    -h, --help       Print help information
    -V, --version    Print version information

OPTIONS:
    -c, --config <RON|JSON|BIN>    override configuration values

SUBCOMMANDS:
    build       build scripts
    clean       clean stuff up
    download    fetch resources
    edit        edit all the things
    help        Print this message or the help of the given subcommand(s)
    init        initialize the shed
    krypt       blackbox
    pack        create packages from file or directory
    pull        fetch resources
    push        commit changes to upstream
    serve       network services
    stash       local storage
    status      print basic info
    store       shared block storage
    unpack      unpack .z or .tz files
    x           do things with runtimes
#+end_example

** contrib
:PROPERTIES:
:CUSTOM_ID: shed-contrib
:END:
+ what -- Third-party code and dependencies with mirrored source trees
+ why -- isolation of external dependencies
+ [[src:contrib][src]]
** crater
:PROPERTIES:
:CUSTOM_ID: shed-crater
:END:
+ what -- a private crate registry for the Rust programming language.
+ [[src:crater][src]]
The [[https://crates.io][crates.io]] package registry provides a number of excellent crates,
integrates well with the =cargo= development tool, and should be
preferred in all cases. I use =crater= when I need to:
- import my unpublished crates
- import the master branch of a published crate
- import a local or patched version of a published crate
- import a non-git crate (hg)

=crater= also works well in intranet/local environments, and can be
deployed for use in the following ways:
- remote :: same as crates.io, registry index is publicly hosted on GitHub (default)
- local :: registry index is stored locally, crates are retrieved remotely
- static :: registry index and crate sources are stored locally, no
  network requests are required

* rlib                                                             :rust:sys:
:PROPERTIES:
:CATEGORY: lib
:CUSTOM_ID: rlib
:EXPORT_FILE_NAME: ../rlib/readme
:END:
=rlib= is a Rust Library. It provides a loose collection of /modules/
which are conditionally compiled via [[https://doc.rust-lang.org/cargo/reference/features.html][features]]. Modules include
boiler-plate, wrappers, errors, helper functions, and some custom
interfaces.

One thing this library does *not* do is re-export an [[https://rust-lang.github.io/async-book/08_ecosystem/00_chapter.html#async-runtimes][async runtime]]. In
earlier versions it re-exported both [[https://github.com/rayon-rs/rayon][rayon]] and [[https://github.com/tokio-rs/tokio][tokio]] as a convenience
to the programmer but this has been phased out. There are however many
=async= functions available in this library, so you should come
equipped with your own runtime if you plan to =.await=.

This is a /personal/ library which is unfit for production use as it
is quite bloated, some of the individual modules are useful on their
own though.

#+CALL: meta-make-tbl()
#+RESULTS:
| info    |                           |
|---------+---------------------------|
| name    | [[https://rwest.io/m#rlib][rlib]]                      |
| version | alpha-0.1                 |
| vc      | [[https://hg.rwest.io/rlib/rev/c3465cc34930][95+:c3465cc34930]], [[https://github.com/richardwesthaver/rlib][github]]  |
| updated | 26 hours ago              |
| lines   | 6946 = λ:6183 #:253 _:952 |
| langs   | (Org RON Rust Text Toml)  |
|---------+---------------------------|

** Usage
:PROPERTIES:
:CUSTOM_ID: rlib-usage
:END:
This crate is not published on crates.io. To get started you'll need
to clone the [[src:rlib][repo]] and add it as a dependency to your project like so:
#+begin_src toml
  [package]
  name = "foo"
  #...
  [dependencies]
  rlib = { version = "0.1.0", path = "../rlib", features = ["kala","logger"]} #include some features
#+end_src

then just use the modules in your code:
#+begin_src rust
  use rlib::{logger, kala};
  use rlib::util::Result;
  fn main() {
    logger::flexi("debug").expect("logger init failed");
    println!("greetings stranger!");
    kala::cmd::sys::describe_host();
  }
#+end_src
* tenex                                                            :rust:net:
:PROPERTIES:
:CATEGORY: lib
:CUSTOM_ID: tenex
:EXPORT_FILE_NAME: ../tenex/readme
:END:
A Rust HTTP Client library.
  - ergonomic wrappers for foreign APIs
  - apps ->
    - cloud management tools (google_drive, gmail, EC2, discord_bots)
    - basic API requests (IP_info, weather_forecast[US only])
    - async task pools (cross_API_chaining, chatbots_with_triggers, deployment_pipelines)

#+CALL: meta-make-tbl()
#+RESULTS:
| info    |                                 |
|---------+---------------------------------|
| name    | [[https://rwest.io/m#tenex][tenex]]                           |
| version | alpha-0.1                       |
| vc      | [[https://hg.rwest.io/tenex/rev/1b94e8c0276b][48+:1b94e8c0276b]], [[https://github.com/richardwesthaver/tenex][github]]        |
| updated | 26 hours ago                    |
| lines   | 6935 = λ:23290 #:155 _:2136     |
| langs   | (Markdown Org Python Rust Toml) |
|---------+---------------------------------|
